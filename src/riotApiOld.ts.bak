import { URL } from "url";

import { Config, EndpointsConfig, EndpointConfig } from "./config";
import { RegionalRequester } from "./regionalRequester";
import { assignPath, format, objFromEntries } from "./utils";

/** `TeemoJS(key [, config])` or `TeemoJS(config)` with `config.key` set. */
export class RiotApi {

    private readonly config: Config;
    private readonly regions: { [key: string]: { [region: string]: RegionalRequester } };

    constructor(key: string | Config, config?: Config /* = RiotApi.defaultConfig */) {
        if ('string' === typeof key && config)
            config.key = key;
        else if (key instanceof Object)
            config = key;
        else
            throw Error('TODO ERROR INVALID ARGS');

        this.config = config;
        this.regions = {};
    }

    req(...args: any[]): any {
        // Get region (first arg, or not).
        let region = this.config.regionPath ? args.shift() : null;
        let [ target, pathParams = {}, queryParams = {}, bodyParam = undefined ] = args;
        if (!(target instanceof String)) throw Error(`First or second argument must be target string.`);
      
        // Get reqConfigs.
        const reqConfigs = [];
        let endpointTree: EndpointsConfig | EndpointConfig = this.config.endpoints;

        for (const segment of target.split('.')) {
            if ('*' in endpointTree) reqConfigs.push(endpointTree['*'])
            if (!(segment in endpointTree)) throw new Error(`Missing path segment "${segment}" in "${target}".`);
            endpointTree = endpointTree[segment];
        }
        reqConfigs.push(endpointTree);
        // Assemble reqConfig.
        const reqConfig = Object.assign({}, ...reqConfigs);
        if (typeof reqConfig.path !== 'string') throw new Error(`Failed to find path for target: "${target}".`);
        reqConfig.fetch = Object.assign({ keepalive: true, redirect: 'follow', headers: {} }, ...reqConfigs.map(rc => rc.fetch));
        reqConfig.fetch.headers = Object.assign({}, ...reqConfigs.map(rc => rc.fetch && rc.fetch.headers));
        reqConfig.pathParams = Object.assign({}, ...reqConfigs.map(rc => rc.pathParams), pathParams);
        reqConfig.queryParams = Object.assign({}, ...reqConfigs.map(rc => rc.queryParams), queryParams);
        reqConfig.bodyParam || (reqConfig.bodyParam = bodyParam);
        // Override key.
        const key = reqConfig.key || this.config.key || null;
        if (this.config.keyPath) assignPath(reqConfig, this.config.keyPath, key);
        // Lookup regions.
        if (this.config.regionPath) {
            if (!reqConfig.regionTable[region]) throw new Error('Failed to determine platform for region: ' +
                `"${region}", available regions (for this endpoint): ${Object.keys(reqConfig.regionTable).join(', ')}.`)
            assignPath(reqConfig, this.config.regionPath, reqConfig.regionTable[region]);
        }
      
        // OriginParams. But first override origin.
        let origin = reqConfig.origin || this.config.origin;
        if (reqConfig.originParams) origin = format(origin, reqConfig.originParams);
      
        // PathParams. Interpolate path.
        if (Array.isArray(pathParams)) // Array.
          pathParams = pathParams.map(encodeURIComponent);
        else if (typeof pathParams === 'object') // Object dict.
          pathParams = objFromEntries(Object.entries(pathParams).map(([ key, val ]) => [ key, encodeURIComponent(val) ]));
        else // Single value.
          pathParams = [ pathParams ];
        const path = format(reqConfig.path, pathParams);
      
        // QueryParams. First build URL.
        const urlBuilder = new URL(path, format(origin, [ region ]));
        // Then build URL query params.
        for (const [ key, vals ] of Object.entries(reqConfig.queryParams)) {
          if (!Array.isArray(vals)) // Not array.
            urlBuilder.searchParams.set(key, vals);
          else if (this.config.collapseQueryArrays) // Array, collapse.
            urlBuilder.searchParams.set(key, vals.join(','));
          else // Array, do not collapse.
            vals.forEach(val => urlBuilder.searchParams.append(key, val));
        }
      
        // BodyParam. Add body, if supplied, to reqConfig.fetch.
        if (undefined !== bodyParam) {
          reqConfig.fetch.body = JSON.stringify(bodyParam);
          reqConfig.fetch.headers['Content-Type'] = 'application/json';
        }
      
        return this._getRegion(region).req(target, urlBuilder.href, reqConfig.fetch);
    };

    /**
     * Limits requests to FACTOR fraction of normal rate limits, allowing multiple
     * instances to be used across multiple processes/machines.
     * This can be called at any time.
     */
    setDistFactor(factor: number): void {
        if (factor <= 0 || factor > 1) throw new Error("Factor must be greater than zero and non-greater than one.");
        if (this.config.distFactor === factor) return;
        this.config.distFactor = factor;
        Object.values(this.regions).forEach(keyRegions => Object.values(keyRegions).forEach(r => r.updateDistFactor()));
      }

    private _getRegion(key: string, region: string): RegionalRequester {
        const keyRegions = this.regions[key] || (this.regions[key] = {});
        return keyRegions[region] || (keyRegions[region] = new RegionalRequester(this.config));
    }
}
