{{
    const dotUtils = require('./dotUtils.js');
    const spec = require('./.spec');
}}{{= dotUtils.PREAMBLE }}

// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version {{= spec.info.version }}
{{
    const endpointGroups = {};
    const endpointMethodGroups = {};

    for (const endpointPair of Object.entries(spec.paths)) {
        const [ path, pathInfo ] = endpointPair;
        const ep = pathInfo['x-endpoint'];
        (endpointGroups[ep] || (endpointGroups[ep] = [])).push(endpointPair);
        endpointMethodGroups[ep] || (endpointMethodGroups[ep] = []);

        const pathParamNames = Array.from(path.matchAll(/\{(\S+?)\}/g)).map(matches => matches[1]);

        for (const [ verb, operation ] of Object.entries(pathInfo)) {
            if (verb.startsWith('x-')) continue;
            const [ endpoint, method ] = operation.operationId.split('.');
            /* const ep = dotUtils.toLowerCamel(endpoint); */
            const descArr = operation.description ? operation.description.split('\n') : [];

            let returnType = 'void';
            const resp200 = operation.responses['200'];
            if (resp200 && resp200.content) {
                const jsonInfo = resp200.content['application/json'];
                const returnTypeOptional = operation['x-nullable-404'];
                returnType = dotUtils.formatPropType(jsonInfo.schema, returnTypeOptional);
            }

            /* TODO: handle body params? */

            /* Build params. */
            const paramsAll = operation.parameters || [];

            const paramsPath = paramsAll.filter(param => 'path' === param.in);
            paramsPath.sort((paramA, paramB) => pathParamNames.indexOf(paramA) - pathParamNames.indexOf(paramB));
            const paramsPathType = dotUtils.paramsToType(paramsPath, true);

            const paramsQuery = paramsAll.filter(param => 'query' === param.in);
            const paramsQueryType = dotUtils.paramsToType(paramsQuery);

            const paramBody = operation.requestBody && operation.requestBody.content && operation.requestBody.content['application/json'];
            const paramBodyType = paramBody ? dotUtils.formatPropType(paramBody.schema) : 'undefined';

            /* const apiKeyName = ep.includes('tft') ? 'tft' : ep.includes('tft') */

            endpointMethodGroups[ep].push({
                path,
                verb,
                descArr,
                method,
                returnType,
                paramsPathType,
                paramsQueryType,
                paramBodyType,
            });
        }
    }
}}

namespace spec {
    export const RiotApi = {
{{
    for (const [ endpointName, endpointMethods ] of Object.entries(endpointMethodGroups))
    {
        const ep = dotUtils.toLowerCamel(endpointName);
}}
        {{= ep }}: {
{{
        for (const endpointMethod of endpointMethods)
        {
            const { path, verb, descArr, method, returnType, paramsPathType, paramsQueryType, paramBodyType } = endpointMethod;
}}
            {{= method }}: {
                path: {{= JSON.stringify(path) }},
{{? 'get' !== verb }}
                method: {{= JSON.stringify(verb) }},
{{?}}
            } as ReqSpec<{{= returnType }}, {{= paramsPathType }}, {{= paramsQueryType }}, {{= paramBodyType }}>,
{{
        }
}}
        },
{{
    }
}}
    };
}
